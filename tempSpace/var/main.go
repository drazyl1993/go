/*
	go语言的变量声明
*/

package main

/*
import (
	"fmt"
)
*/

var xx = 100

func main() {
	var x int
	println(&x, x)
	// 执行发现:go竟然有一个println函数可以直接用，不需要fmt的Println
	// 并且如果import fmt 而没有使用，编译会报错。

	var f = false
	var f1 = 3
	println(&f, f)
	println(&f1, f1)
	// 执行发现：如果声明变量并且直接初始化了变量的值，go编译器会根据初始化的值，自动给予数据类型，编译不会报错。

	var x1, y int
	println(&x1, x1)
	println(&y, y)
	// 执行发现：go支持多变量同时赋值,并且，变量生命的时候如果指定了变量的类型，却没有给出初始化的值，编译器会自己根据指定的类型给一个初始化的值.

	var x2, y1 = 3, "a"
	println(&x2, x2)
	println(&y1, y1)
	// 执行发现：同时声明多个变量，变量类型可以不同，赋值是按顺序来的。

	var (
		x3, y2 int
		x4, y3 = 100, "b"
	)
	println(&x3, x3)
	println(&x4, x4)
	println(&y2, y2)
	println(&y3, y3)
	// 执行发现：变量可以用块儿来定义，只用一个var，这个在java和python中还没有见过。不知道java和python是否支持。

	x5 := 100
	x6, y4 := 123, "c"
	println(&x5, x5)
	println(&x6, x6)
	println(&y4, y4)
	// 执行发现：变量声明不需要关键字。用:=来定义，只能定义在函数内部，必须直接初始化，并且必须灭有数据类型，所谓变量声明的简短模式。

	println(&xx, xx)
	xx := "d"
	println(&xx, xx)
	method1()
	// 执行发现：在方法外部声明了一个全局变量xx，然后简短式声明和初始化与全局变量名一致，go编译器会新申请一块儿内存来存放局部的赋值，xx变量名的引用也被指向新的地址。这个新地址的作用域也仅仅是这个局部。method1方法打印的结果仍然是局部变量，所以在method1的作用域中xx没有新的地址。

	xx1 := 100
	println(&xx1, xx1)
	// 执行发现：根据语法高亮的配置，go应该也有print内置函数可以用。ln是换行输出。另外，&看来是取址符，打印拼接的符号目前接触到的看，应该是，而非+号。

	xx1, yy1 := 200, "e"
	println(&xx1, xx1)
	println(&yy1, yy1)
	// 执行发现: 掐面一段代码，箭式生命了xx1，然后可见在这段代码中又声明赋值了一次，与前面的局部变量简式声明新申请了一块儿内存的差异在于，这次赋值没有新申请内存，而是修改了原内存所存放的值。前提是同一个变量的两次声明都在同一个作用域当中，并且最少有一个新的变量被定义，难道是说，变量的赋值操作，必须至少申请一块儿内存么，为什么必须要有一个新的变量被定义呢？

	xx1 := 300
	// 报错内容：./main.go:69: no new variables on left side of :=
	// 前面一段代码，为了测试上面的结论，没有新的变量被定义的情况下，对同一个作用域的进行第二次简式赋值，这时应该叫做退化赋值，但是执行报错，检验了必须有新的变量被定义的结论。

}

func method1() {
	println(&xx, xx)
}
