/*
	go语言的变量声明
	1.声明变量使用var 关键字，简式声明是不需要的。
	2.声明变量的时候可以直接复制，var i = 0，此时无需声明数据类型，编译器会自己判断。
	3.可以同时声明多个类型不一样的变量，var i,j = 3,"str"。
	4.go如果声明变量没有初始化，go会根据所声明的数据类型进行初始化赋值。
	5.简式赋值和退化赋值
	6.简式赋值:= 不必使用var关键字，不必声明数据类型。但必须给出初始化值
	7.退化赋值，同一个通过简化赋值声明的变量，在不同的作用于，退化赋值对内存有不同得操作。
*/

package main

/*
import (
	"fmt"
)
*/

var xx = 100
var xxx = 1

func main() {
	println("--------------------------------------------------------------------")
	var x int
	println(&x, x)
	// 执行发现:go竟然有一个println函数可以直接用，不需要fmt的Println
	// 并且如果import fmt 而没有使用，编译会报错。

	println("--------------------------------------------------------------------")
	var f = false
	var f1 = 3
	println(&f, f)
	println(&f1, f1)
	// 执行发现：如果声明变量并且直接初始化了变量的值，go编译器会根据初始化的值，自动给予数据类型，编译不会报错。

	println("--------------------------------------------------------------------")
	var x1, y int
	println(&x1, x1)
	println(&y, y)
	// 执行发现：go支持多变量同时赋值,并且，变量生命的时候如果指定了变量的类型，却没有给出初始化的值，编译器会自己根据指定的类型给一个初始化的值.

	println("--------------------------------------------------------------------")
	var x2, y1 = 3, "a"
	println(&x2, x2)
	println(&y1, y1)
	// 执行发现：同时声明多个变量，变量类型可以不同，赋值是按顺序来的。

	println("--------------------------------------------------------------------")
	var (
		x3, y2 int
		x4, y3 = 100, "b"
	)
	println(&x3, x3)
	println(&x4, x4)
	println(&y2, y2)
	println(&y3, y3)
	// 执行发现：变量可以用块儿来定义，只用一个var，这个在java和python中还没有见过。不知道java和python是否支持。

	println("--------------------------------------------------------------------")
	x5 := 100
	x6, y4 := 123, "c"
	println(&x5, x5)
	println(&x6, x6)
	println(&y4, y4)
	// 执行发现：变量声明不需要关键字。用:=来定义，只能定义在函数内部，必须直接初始化，并且必须灭有数据类型，所谓变量声明的简短模式。

	println("--------------------------------------------------------------------")
	println(&xx, xx)
	xx := "d"
	println(&xx, xx)
	method1()
	// 执行发现：在方法外部声明了一个全局变量xx，然后简短式声明和初始化与全局变量名一致，go编译器会新申请一块儿内存来存放局部的赋值，xx变量名的引用也被指向新的地址。这个新地址的作用域也仅仅是这个局部。method1方法打印的结果仍然是局部变量，所以在method1的作用域中xx没有新的地址。

	println("--------------------------------------------------------------------")
	xx1 := 100
	println(&xx1, xx1)
	// 执行发现：根据语法高亮的配置，go应该也有print内置函数可以用。ln是换行输出。另外，&看来是取址符，打印拼接的符号目前接触到的看，应该是，而非+号。

	println("--------------------------------------------------------------------")
	xx1, yy1 := 200, "e"
	println(&xx1, xx1)
	println(&yy1, yy1)
	// 执行发现: 掐面一段代码，箭式生命了xx1，然后可见在这段代码中又声明赋值了一次，与前面的局部变量简式声明新申请了一块儿内存的差异在于，这次赋值没有新申请内存，而是修改了原内存所存放的值。前提是同一个变量的两次声明都在同一个作用域当中，并且最少有一个新的变量被定义，难道是说，变量的赋值操作，必须至少申请一块儿内存么，为什么必须要有一个新的变量被定义呢？

	//错误示例
	// xx1 := 300
	// 报错内容：./main.go:69: no new variables on left side of :=
	// 前面一段代码，为了测试上面的结论，没有新的变量被定义的情况下，对同一个作用域的进行第二次简式赋值，这时应该叫做退化赋值，但是执行报错，检验了必须有新的变量被定义的结论。

	println("--------------------------------------------------------------------")
	xx2 := 100
	println(&xx2, xx2)
	{
		xx2, yy2 := 200, "f"
		println(&xx2, xx2)
		println(&yy2, yy2)
	}
	// 执行发现,当简式赋值，不在同一个作用局中的时候，表现为新变量的定义，也就是说新申请了内存，可以发现，只要作用域不一样，编译器会在当前作用域中重新为变量申请内存。

	// go好像没有try catch ，退化赋值在处理函数错误的时候尤其有用。

	xx3, yy3 := 1, 2
	//xx3, yy3 := xx3+3, yy3+2
	// 上面一行代码run的时候报错了，因为同一个作用域，没有新变量被定义。。。
	xx3, yy3 = yy3+2, xx3+2
	println(&xx3, xx3)
	println(&yy3, yy3)

	//错误示例
	//xx3, yy3 := 1, "2"
	//xx3, yy3 := xx3+3, yy3+2
	// 上面一行代码run的时候报错了，因为同一个作用域，没有新变量被定义。。。
	//xx3, yy3 = "2", xx3+2
	//println(&xx3, xx3)
	//println(&yy3, yy3)
	// 执行发现：多变量赋值和多变量定义是不一样的。多变量声明可以声明不同的数据类型，但是多变量赋值的时候必须保证变量的数据类型是一样的！

	//错误示例
	//xx4 := 1
	// 执行发现，局部变量如果声明了就必须使用，没有使用的话会报错。./main.go:109: xx4 declared and not used,但是全局变量是可以的！
}

func method1() {
	println(&xx, xx)
}
